
"                                                   The License
 
 The user is free to produce commercial applications with the software, to distribute these applications in source or binary  form, and to charge monies for them as he sees fit and in concordance with the laws of the land subject to the following  license.
 
 1. The license applies to all the software and all derived software and must appear on such.
 2. It is illegal to distribute the software without this license attached to it and use of the software implies agreement 
    with the license as such. It is illegal for anyone who is not the copyright holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used to endorse or promote products built using
     the software without specific prior written permission from the copyright holder.
 4. That possession of this license does not confer on the copyright holder any special contractual obligation towards the    user. That in no event shall the copyright holder be liable for any direct, indirect, incidental, special, exemplary or   consequential damages (including but not limited to procurement of substitute goods or services, loss of use, data, or    profits; or business interruption), however caused and on any theory of liability, whether in contract, strict liability   or tort (including negligence) arising in any way out of the use of the software, even if advised of the possibility of   such damage. 
5. It is permitted for the user to change the software, for the purpose of improving performance, correcting an error, or    porting to a new platform, and distribute the modified version of Shen (hereafter the modified version) provided the     resulting program conforms in all respects to the Shen standard and is issued under that title. The user must make it clear   with his distribution that he/she is the author of the changes and what these changes are and why. 
6. Derived versions of this software in whatever form are subject to the same restrictions. In particular it is not          permitted to make derived copies of this software which do not conform to the Shen standard or appear under a different title.
7. It is permitted to distribute versions of Shen which incorporate libraries, graphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june11/license.htm which explains this license in full."

(set shen-*charcodes* (absvector 256))

(address-> (value shen-*charcodes*) 126 "~")

(address-> (value shen-*charcodes*) 125 "}")

(address-> (value shen-*charcodes*) 124 "|")

(address-> (value shen-*charcodes*) 123 "{")

(address-> (value shen-*charcodes*) 122 "z")

(address-> (value shen-*charcodes*) 121 "y")

(address-> (value shen-*charcodes*) 120 "x")

(address-> (value shen-*charcodes*) 119 "w")

(address-> (value shen-*charcodes*) 118 "v")

(address-> (value shen-*charcodes*) 117 "u")

(address-> (value shen-*charcodes*) 116 "t")

(address-> (value shen-*charcodes*) 115 "s")

(address-> (value shen-*charcodes*) 114 "r")

(address-> (value shen-*charcodes*) 113 "q")

(address-> (value shen-*charcodes*) 112 "p")

(address-> (value shen-*charcodes*) 111 "o")

(address-> (value shen-*charcodes*) 110 "n")

(address-> (value shen-*charcodes*) 109 "m")

(address-> (value shen-*charcodes*) 108 "l")

(address-> (value shen-*charcodes*) 107 "k")

(address-> (value shen-*charcodes*) 106 "j")

(address-> (value shen-*charcodes*) 105 "i")

(address-> (value shen-*charcodes*) 104 "h")

(address-> (value shen-*charcodes*) 103 "g")

(address-> (value shen-*charcodes*) 102 "f")

(address-> (value shen-*charcodes*) 101 "e")

(address-> (value shen-*charcodes*) 100 "d")

(address-> (value shen-*charcodes*) 99 "c")

(address-> (value shen-*charcodes*) 98 "b")

(address-> (value shen-*charcodes*) 97 "a")

(address-> (value shen-*charcodes*) 96 "`")

(address-> (value shen-*charcodes*) 95 "_")

(address-> (value shen-*charcodes*) 94 "^")

(address-> (value shen-*charcodes*) 93 "]")

(address-> (value shen-*charcodes*) 92 "\\")

(address-> (value shen-*charcodes*) 91 "[")

(address-> (value shen-*charcodes*) 90 "Z")

(address-> (value shen-*charcodes*) 89 "Y")

(address-> (value shen-*charcodes*) 88 "X")

(address-> (value shen-*charcodes*) 87 "W")

(address-> (value shen-*charcodes*) 86 "V")

(address-> (value shen-*charcodes*) 85 "U")

(address-> (value shen-*charcodes*) 84 "T")

(address-> (value shen-*charcodes*) 83 "S")

(address-> (value shen-*charcodes*) 82 "R")

(address-> (value shen-*charcodes*) 81 "Q")

(address-> (value shen-*charcodes*) 80 "P")

(address-> (value shen-*charcodes*) 79 "O")

(address-> (value shen-*charcodes*) 78 "N")

(address-> (value shen-*charcodes*) 77 "M")

(address-> (value shen-*charcodes*) 76 "L")

(address-> (value shen-*charcodes*) 75 "K")

(address-> (value shen-*charcodes*) 74 "J")

(address-> (value shen-*charcodes*) 73 "I")

(address-> (value shen-*charcodes*) 72 "H")

(address-> (value shen-*charcodes*) 71 "G")

(address-> (value shen-*charcodes*) 70 "F")

(address-> (value shen-*charcodes*) 69 "E")

(address-> (value shen-*charcodes*) 68 "D")

(address-> (value shen-*charcodes*) 67 "C")

(address-> (value shen-*charcodes*) 66 "B")

(address-> (value shen-*charcodes*) 65 "A")

(address-> (value shen-*charcodes*) 64 "@")

(address-> (value shen-*charcodes*) 63 "?")

(address-> (value shen-*charcodes*) 62 ">")

(address-> (value shen-*charcodes*) 61 "=")

(address-> (value shen-*charcodes*) 60 "<")

(address-> (value shen-*charcodes*) 59 ";")

(address-> (value shen-*charcodes*) 58 ":")

(address-> (value shen-*charcodes*) 57 "9")

(address-> (value shen-*charcodes*) 56 "8")

(address-> (value shen-*charcodes*) 55 "7")

(address-> (value shen-*charcodes*) 54 "6")

(address-> (value shen-*charcodes*) 53 "5")

(address-> (value shen-*charcodes*) 52 "4")

(address-> (value shen-*charcodes*) 51 "3")

(address-> (value shen-*charcodes*) 50 "2")

(address-> (value shen-*charcodes*) 49 "1")

(address-> (value shen-*charcodes*) 48 "0")

(address-> (value shen-*charcodes*) 47 "/")

(address-> (value shen-*charcodes*) 46 ".")

(address-> (value shen-*charcodes*) 45 "-")

(address-> (value shen-*charcodes*) 44 ",")

(address-> (value shen-*charcodes*) 43 "+")

(address-> (value shen-*charcodes*) 42 "*")

(address-> (value shen-*charcodes*) 41 ")")

(address-> (value shen-*charcodes*) 40 "(")

(address-> (value shen-*charcodes*) 39 "'")

(address-> (value shen-*charcodes*) 38 "&")

(address-> (value shen-*charcodes*) 37 "%")

(address-> (value shen-*charcodes*) 36 "$")

(address-> (value shen-*charcodes*) 35 "#")

(address-> (value shen-*charcodes*) 34
 (if (= (value *language*) "Common Lisp") (FORMAT () "~C" (CODE-CHAR 34))
  (interror "code char 34 undefined~%" ())))

(address-> (value shen-*charcodes*) 33 "!")

(address-> (value shen-*charcodes*) 32 " ")

(address-> (value shen-*charcodes*) 13
 "
")

(address-> (value shen-*charcodes*) 10
 "
")

(address-> (value shen-*charcodes*) 9 "	")

(set shen-*symbolcodes* (vector 128))

(address-> (value shen-*symbolcodes*) 126 "~")

(address-> (value shen-*symbolcodes*) 122 "z")

(address-> (value shen-*symbolcodes*) 121 "y")

(address-> (value shen-*symbolcodes*) 120 "x")

(address-> (value shen-*symbolcodes*) 119 "w")

(address-> (value shen-*symbolcodes*) 118 "v")

(address-> (value shen-*symbolcodes*) 117 "u")

(address-> (value shen-*symbolcodes*) 116 "t")

(address-> (value shen-*symbolcodes*) 115 "s")

(address-> (value shen-*symbolcodes*) 114 "r")

(address-> (value shen-*symbolcodes*) 113 "q")

(address-> (value shen-*symbolcodes*) 112 "p")

(address-> (value shen-*symbolcodes*) 111 "o")

(address-> (value shen-*symbolcodes*) 110 "n")

(address-> (value shen-*symbolcodes*) 109 "m")

(address-> (value shen-*symbolcodes*) 108 "l")

(address-> (value shen-*symbolcodes*) 107 "k")

(address-> (value shen-*symbolcodes*) 106 "j")

(address-> (value shen-*symbolcodes*) 105 "i")

(address-> (value shen-*symbolcodes*) 104 "h")

(address-> (value shen-*symbolcodes*) 103 "g")

(address-> (value shen-*symbolcodes*) 102 "f")

(address-> (value shen-*symbolcodes*) 101 "e")

(address-> (value shen-*symbolcodes*) 100 "d")

(address-> (value shen-*symbolcodes*) 99 "c")

(address-> (value shen-*symbolcodes*) 98 "b")

(address-> (value shen-*symbolcodes*) 97 "a")

(address-> (value shen-*symbolcodes*) 96
 (if (= (value *language*) "Common Lisp") "_backquote" "`"))

(address-> (value shen-*symbolcodes*) 95 "_")

(address-> (value shen-*symbolcodes*) 90 "Z")

(address-> (value shen-*symbolcodes*) 89 "Y")

(address-> (value shen-*symbolcodes*) 88 "X")

(address-> (value shen-*symbolcodes*) 87 "W")

(address-> (value shen-*symbolcodes*) 86 "V")

(address-> (value shen-*symbolcodes*) 85 "U")

(address-> (value shen-*symbolcodes*) 84 "T")

(address-> (value shen-*symbolcodes*) 83 "S")

(address-> (value shen-*symbolcodes*) 82 "R")

(address-> (value shen-*symbolcodes*) 81 "Q")

(address-> (value shen-*symbolcodes*) 80 "P")

(address-> (value shen-*symbolcodes*) 79 "O")

(address-> (value shen-*symbolcodes*) 78 "N")

(address-> (value shen-*symbolcodes*) 77 "M")

(address-> (value shen-*symbolcodes*) 76 "L")

(address-> (value shen-*symbolcodes*) 75 "K")

(address-> (value shen-*symbolcodes*) 74 "J")

(address-> (value shen-*symbolcodes*) 73 "I")

(address-> (value shen-*symbolcodes*) 72 "H")

(address-> (value shen-*symbolcodes*) 71 "G")

(address-> (value shen-*symbolcodes*) 70 "F")

(address-> (value shen-*symbolcodes*) 69 "E")

(address-> (value shen-*symbolcodes*) 68 "D")

(address-> (value shen-*symbolcodes*) 67 "C")

(address-> (value shen-*symbolcodes*) 66 "B")

(address-> (value shen-*symbolcodes*) 65 "A")

(address-> (value shen-*symbolcodes*) 64 "@")

(address-> (value shen-*symbolcodes*) 63 "?")

(address-> (value shen-*symbolcodes*) 62 ">")

(address-> (value shen-*symbolcodes*) 61 "=")

(address-> (value shen-*symbolcodes*) 60 "<")

(address-> (value shen-*symbolcodes*) 57 "9")

(address-> (value shen-*symbolcodes*) 56 "8")

(address-> (value shen-*symbolcodes*) 55 "7")

(address-> (value shen-*symbolcodes*) 54 "6")

(address-> (value shen-*symbolcodes*) 53 "5")

(address-> (value shen-*symbolcodes*) 52 "4")

(address-> (value shen-*symbolcodes*) 51 "3")

(address-> (value shen-*symbolcodes*) 50 "2")

(address-> (value shen-*symbolcodes*) 49 "1")

(address-> (value shen-*symbolcodes*) 48 "0")

(address-> (value shen-*symbolcodes*) 47 "/")

(address-> (value shen-*symbolcodes*) 46 ".")

(address-> (value shen-*symbolcodes*) 45 "-")

(address-> (value shen-*symbolcodes*) 43 "+")

(address-> (value shen-*symbolcodes*) 42 "*")

(address-> (value shen-*symbolcodes*) 39
 (if (= (value *language*) "Common Lisp") "_quote" "'"))

(address-> (value shen-*symbolcodes*) 38 "&")

(address-> (value shen-*symbolcodes*) 37 "%")

(address-> (value shen-*symbolcodes*) 36 "$")

(address-> (value shen-*symbolcodes*) 35
 (if (= (value *language*) "Common Lisp") "_hash" "#"))

(address-> (value shen-*symbolcodes*) 33 "!")

(defun byte->string (V916) (<-address (value shen-*charcodes*) V916))

(defun lineread () (shen-lineread-loop (read-byte (stinput 0)) ()))

(defun shen-lineread-loop (V918 V919)
 (cond ((= V918 (shen-hat)) (interror "line read aborted" ()))
  ((element? V918 (cons (shen-newline) (cons (shen-carriage-return) ())))
   (let Line (compile (function shen-<st_input>) V919 ())
    (if (or (= Line (fail)) (empty? Line))
     (shen-lineread-loop (read-byte (stinput 0)) (append V919 (cons V918 ())))
     Line)))
  (true
   (shen-lineread-loop (read-byte (stinput 0))
    (append V919 (cons V918 ()))))))

(defun read-file (V920)
 (let Bytelist (read-file-as-bytelist V920)
  (compile (function shen-<st_input>) Bytelist (function shen-read-error))))

(defun shen-read-error (V921)
 (interror "read error here:~%~% ~A~%" (@p (shen-compress-50 50 V921) ())))

(defun shen-compress-50 (V926 V927)
 (cond ((= () V927) "") ((= 0 V926) "")
  ((cons? V927)
   (cn (byte->string (hd V927)) (shen-compress-50 (- V926 1) (tl V927))))
  (true (shen-sys-error shen-compress-50))))

(defun shen-<st_input> (V928)
 (let Result
  (let Parse_<lsb> (shen-<lsb> V928)
   (if (not (= (fail) Parse_<lsb>))
    (let Parse_<st_input1> (shen-<st_input1> Parse_<lsb>)
     (if (not (= (fail) Parse_<st_input1>))
      (let Parse_<rsb> (shen-<rsb> Parse_<st_input1>)
       (if (not (= (fail) Parse_<rsb>))
        (let Parse_<st_input2> (shen-<st_input2> Parse_<rsb>)
         (if (not (= (fail) Parse_<st_input2>))
          (shen-reassemble (fst Parse_<st_input2>)
           (cons (macroexpand (shen-cons_form (snd Parse_<st_input1>)))
            (snd Parse_<st_input2>)))
          (fail)))
        (fail)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<lrb> (shen-<lrb> V928)
     (if (not (= (fail) Parse_<lrb>))
      (let Parse_<st_input1> (shen-<st_input1> Parse_<lrb>)
       (if (not (= (fail) Parse_<st_input1>))
        (let Parse_<rrb> (shen-<rrb> Parse_<st_input1>)
         (if (not (= (fail) Parse_<rrb>))
          (let Parse_<st_input2> (shen-<st_input2> Parse_<rrb>)
           (if (not (= (fail) Parse_<st_input2>))
            (shen-reassemble (fst Parse_<st_input2>)
             (shen-package-macro (macroexpand (snd Parse_<st_input1>))
              (snd Parse_<st_input2>)))
            (fail)))
          (fail)))
        (fail)))
      (fail)))
    (if (= Result (fail))
     (let Result
      (let Parse_<lcurly> (shen-<lcurly> V928)
       (if (not (= (fail) Parse_<lcurly>))
        (let Parse_<st_input> (shen-<st_input> Parse_<lcurly>)
         (if (not (= (fail) Parse_<st_input>))
          (shen-reassemble (fst Parse_<st_input>)
           (cons { (snd Parse_<st_input>)))
          (fail)))
        (fail)))
      (if (= Result (fail))
       (let Result
        (let Parse_<rcurly> (shen-<rcurly> V928)
         (if (not (= (fail) Parse_<rcurly>))
          (let Parse_<st_input> (shen-<st_input> Parse_<rcurly>)
           (if (not (= (fail) Parse_<st_input>))
            (shen-reassemble (fst Parse_<st_input>)
             (cons } (snd Parse_<st_input>)))
            (fail)))
          (fail)))
        (if (= Result (fail))
         (let Result
          (let Parse_<bar> (shen-<bar> V928)
           (if (not (= (fail) Parse_<bar>))
            (let Parse_<st_input> (shen-<st_input> Parse_<bar>)
             (if (not (= (fail) Parse_<st_input>))
              (shen-reassemble (fst Parse_<st_input>)
               (cons bar! (snd Parse_<st_input>)))
              (fail)))
            (fail)))
          (if (= Result (fail))
           (let Result
            (let Parse_<semicolon> (shen-<semicolon> V928)
             (if (not (= (fail) Parse_<semicolon>))
              (let Parse_<st_input> (shen-<st_input> Parse_<semicolon>)
               (if (not (= (fail) Parse_<st_input>))
                (shen-reassemble (fst Parse_<st_input>)
                 (cons ; (snd Parse_<st_input>)))
                (fail)))
              (fail)))
            (if (= Result (fail))
             (let Result
              (let Parse_<colon> (shen-<colon> V928)
               (if (not (= (fail) Parse_<colon>))
                (let Parse_<equal> (shen-<equal> Parse_<colon>)
                 (if (not (= (fail) Parse_<equal>))
                  (let Parse_<st_input> (shen-<st_input> Parse_<equal>)
                   (if (not (= (fail) Parse_<st_input>))
                    (shen-reassemble (fst Parse_<st_input>)
                     (cons := (snd Parse_<st_input>)))
                    (fail)))
                  (fail)))
                (fail)))
              (if (= Result (fail))
               (let Result
                (let Parse_<colon> (shen-<colon> V928)
                 (if (not (= (fail) Parse_<colon>))
                  (let Parse_<minus> (shen-<minus> Parse_<colon>)
                   (if (not (= (fail) Parse_<minus>))
                    (let Parse_<st_input> (shen-<st_input> Parse_<minus>)
                     (if (not (= (fail) Parse_<st_input>))
                      (shen-reassemble (fst Parse_<st_input>)
                       (cons :- (snd Parse_<st_input>)))
                      (fail)))
                    (fail)))
                  (fail)))
                (if (= Result (fail))
                 (let Result
                  (let Parse_<colon> (shen-<colon> V928)
                   (if (not (= (fail) Parse_<colon>))
                    (let Parse_<st_input> (shen-<st_input> Parse_<colon>)
                     (if (not (= (fail) Parse_<st_input>))
                      (shen-reassemble (fst Parse_<st_input>)
                       (cons : (snd Parse_<st_input>)))
                      (fail)))
                    (fail)))
                  (if (= Result (fail))
                   (let Result
                    (let Parse_<comma> (shen-<comma> V928)
                     (if (not (= (fail) Parse_<comma>))
                      (let Parse_<st_input> (shen-<st_input> Parse_<comma>)
                       (if (not (= (fail) Parse_<st_input>))
                        (shen-reassemble (fst Parse_<st_input>)
                         (cons shen- (snd Parse_<st_input>)))
                        (fail)))
                      (fail)))
                    (if (= Result (fail))
                     (let Result
                      (let Parse_<comment> (shen-<comment> V928)
                       (if (not (= (fail) Parse_<comment>))
                        (let Parse_<st_input> (shen-<st_input> Parse_<comment>)
                         (if (not (= (fail) Parse_<st_input>))
                          (shen-reassemble (fst Parse_<st_input>)
                           (snd Parse_<st_input>))
                          (fail)))
                        (fail)))
                      (if (= Result (fail))
                       (let Result
                        (let Parse_<atom> (shen-<atom> V928)
                         (if (not (= (fail) Parse_<atom>))
                          (let Parse_<st_input> (shen-<st_input> Parse_<atom>)
                           (if (not (= (fail) Parse_<st_input>))
                            (shen-reassemble (fst Parse_<st_input>)
                             (cons (macroexpand (snd Parse_<atom>))
                              (snd Parse_<st_input>)))
                            (fail)))
                          (fail)))
                        (if (= Result (fail))
                         (let Result
                          (let Parse_<whitespaces> (shen-<whitespaces> V928)
                           (if (not (= (fail) Parse_<whitespaces>))
                            (let Parse_<st_input>
                             (shen-<st_input> Parse_<whitespaces>)
                             (if (not (= (fail) Parse_<st_input>))
                              (shen-reassemble (fst Parse_<st_input>)
                               (snd Parse_<st_input>))
                              (fail)))
                            (fail)))
                          (if (= Result (fail))
                           (let Result
                            (let Parse_<e> (<e> V928)
                             (if (not (= (fail) Parse_<e>))
                              (shen-reassemble (fst Parse_<e>) ()) (fail)))
                            (if (= Result (fail)) (fail) Result))
                           Result))
                         Result))
                       Result))
                     Result))
                   Result))
                 Result))
               Result))
             Result))
           Result))
         Result))
       Result))
     Result))
   Result)))

(defun shen-<lsb> (V929)
 (let Result
  (if (cons? (fst V929))
   (shen-reassemble (fst (shen-reassemble (tl (fst V929)) (snd V929)))
    (if (= (hd (fst V929)) 91) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<rsb> (V930)
 (let Result
  (if (cons? (fst V930))
   (shen-reassemble (fst (shen-reassemble (tl (fst V930)) (snd V930)))
    (if (= (hd (fst V930)) 93) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<lcurly> (V931)
 (let Result
  (if (cons? (fst V931))
   (shen-reassemble (fst (shen-reassemble (tl (fst V931)) (snd V931)))
    (if (= (hd (fst V931)) 123) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<rcurly> (V932)
 (let Result
  (if (cons? (fst V932))
   (shen-reassemble (fst (shen-reassemble (tl (fst V932)) (snd V932)))
    (if (= (hd (fst V932)) 125) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<bar> (V933)
 (let Result
  (if (cons? (fst V933))
   (shen-reassemble (fst (shen-reassemble (tl (fst V933)) (snd V933)))
    (if (= (hd (fst V933)) 124) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<semicolon> (V934)
 (let Result
  (if (cons? (fst V934))
   (shen-reassemble (fst (shen-reassemble (tl (fst V934)) (snd V934)))
    (if (= (hd (fst V934)) 59) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<colon> (V935)
 (let Result
  (if (cons? (fst V935))
   (shen-reassemble (fst (shen-reassemble (tl (fst V935)) (snd V935)))
    (if (= (hd (fst V935)) 58) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<comma> (V936)
 (let Result
  (if (cons? (fst V936))
   (shen-reassemble (fst (shen-reassemble (tl (fst V936)) (snd V936)))
    (if (= (hd (fst V936)) 44) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<equal> (V937)
 (let Result
  (if (cons? (fst V937))
   (shen-reassemble (fst (shen-reassemble (tl (fst V937)) (snd V937)))
    (if (= (hd (fst V937)) 61) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<minus> (V938)
 (let Result
  (if (cons? (fst V938))
   (shen-reassemble (fst (shen-reassemble (tl (fst V938)) (snd V938)))
    (if (= (hd (fst V938)) 45) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<lrb> (V939)
 (let Result
  (if (cons? (fst V939))
   (shen-reassemble (fst (shen-reassemble (tl (fst V939)) (snd V939)))
    (if (= (hd (fst V939)) 40) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<rrb> (V940)
 (let Result
  (if (cons? (fst V940))
   (shen-reassemble (fst (shen-reassemble (tl (fst V940)) (snd V940)))
    (if (= (hd (fst V940)) 41) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<atom> (V941)
 (let Result
  (let Parse_<str> (shen-<str> V941)
   (if (not (= (fail) Parse_<str>))
    (shen-reassemble (fst Parse_<str>) (snd Parse_<str>)) (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<number> (shen-<number> V941)
     (if (not (= (fail) Parse_<number>))
      (shen-reassemble (fst Parse_<number>) (snd Parse_<number>)) (fail)))
    (if (= Result (fail))
     (let Result
      (let Parse_<sym> (shen-<sym> V941)
       (if (not (= (fail) Parse_<sym>))
        (shen-reassemble (fst Parse_<sym>) (snd Parse_<sym>)) (fail)))
      (if (= Result (fail)) (fail) Result))
     Result))
   Result)))

(defun shen-<sym> (V942)
 (let Result
  (let Parse_<alpha> (shen-<alpha> V942)
   (if (not (= (fail) Parse_<alpha>))
    (let Parse_<symchars> (shen-<symchars> Parse_<alpha>)
     (if (not (= (fail) Parse_<symchars>))
      (shen-reassemble (fst Parse_<symchars>)
       (intern (cn (snd Parse_<alpha>) (snd Parse_<symchars>))))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<alpha> (shen-<alpha> V942)
     (if (not (= (fail) Parse_<alpha>))
      (shen-reassemble (fst Parse_<alpha>) (intern (snd Parse_<alpha>)))
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<symchars> (V943)
 (let Result
  (let Parse_<symchar> (shen-<symchar> V943)
   (if (not (= (fail) Parse_<symchar>))
    (let Parse_<symchars> (shen-<symchars> Parse_<symchar>)
     (if (not (= (fail) Parse_<symchars>))
      (shen-reassemble (fst Parse_<symchars>)
       (cn (snd Parse_<symchar>) (snd Parse_<symchars>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<symchar> (shen-<symchar> V943)
     (if (not (= (fail) Parse_<symchar>))
      (shen-reassemble (fst Parse_<symchar>) (snd Parse_<symchar>)) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<symchar> (V944)
 (let Result
  (let Parse_<alpha> (shen-<alpha> V944)
   (if (not (= (fail) Parse_<alpha>))
    (shen-reassemble (fst Parse_<alpha>) (snd Parse_<alpha>)) (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<digit->string> (shen-<digit->string> V944)
     (if (not (= (fail) Parse_<digit->string>))
      (shen-reassemble (fst Parse_<digit->string>) (snd Parse_<digit->string>))
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<digit->string> (V945)
 (let Result
  (if (cons? (fst V945))
   (shen-reassemble (fst (shen-reassemble (tl (fst V945)) (snd V945)))
    (if (shen-digit-byte? (hd (fst V945))) (byte->string (hd (fst V945)))
     (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-digit-byte? (V950)
 (cond ((= 48 V950) true) ((= 49 V950) true) ((= 50 V950) true)
  ((= 51 V950) true) ((= 52 V950) true) ((= 53 V950) true)
  ((= 54 V950) true) ((= 55 V950) true) ((= 56 V950) true)
  ((= 57 V950) true) (true false)))

(defun shen-<alpha> (V951)
 (let Result
  (if (cons? (fst V951))
   (shen-reassemble (fst (shen-reassemble (tl (fst V951)) (snd V951)))
    (let S (shen-symbol-byte->string (hd (fst V951)))
     (if (= S (fail)) (fail) S)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-symbol-byte->string (V952)
 (<-address (value shen-*symbolcodes*) V952))

(defun shen-<str> (V953)
 (let Result
  (let Parse_<dbq> (shen-<dbq> V953)
   (if (not (= (fail) Parse_<dbq>))
    (let Parse_<strcontents> (shen-<strcontents> Parse_<dbq>)
     (if (not (= (fail) Parse_<strcontents>))
      (let Parse_<dbq> (shen-<dbq> Parse_<strcontents>)
       (if (not (= (fail) Parse_<dbq>))
        (shen-reassemble (fst Parse_<dbq>) (snd Parse_<strcontents>)) (fail)))
      (fail)))
    (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<dbq> (V954)
 (let Result
  (if (cons? (fst V954))
   (shen-reassemble (fst (shen-reassemble (tl (fst V954)) (snd V954)))
    (if (= (hd (fst V954)) 34) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<strcontents> (V955)
 (let Result
  (let Parse_<backslash> (shen-<backslash> V955)
   (if (not (= (fail) Parse_<backslash>))
    (let Parse_<byte> (shen-<byte> Parse_<backslash>)
     (if (not (= (fail) Parse_<byte>))
      (let Parse_<strcontents> (shen-<strcontents> Parse_<byte>)
       (if (not (= (fail) Parse_<strcontents>))
        (shen-reassemble (fst Parse_<strcontents>)
         (cn (snd Parse_<byte>) (snd Parse_<strcontents>)))
        (fail)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<strc> (shen-<strc> V955)
     (if (not (= (fail) Parse_<strc>))
      (let Parse_<strcontents> (shen-<strcontents> Parse_<strc>)
       (if (not (= (fail) Parse_<strcontents>))
        (shen-reassemble (fst Parse_<strcontents>)
         (cn (snd Parse_<strc>) (snd Parse_<strcontents>)))
        (fail)))
      (fail)))
    (if (= Result (fail))
     (let Result
      (let Parse_<e> (<e> V955)
       (if (not (= (fail) Parse_<e>)) (shen-reassemble (fst Parse_<e>) "")
        (fail)))
      (if (= Result (fail)) (fail) Result))
     Result))
   Result)))

(defun shen-<byte> (V956)
 (let Result
  (if (cons? (fst V956))
   (shen-reassemble (fst (shen-reassemble (tl (fst V956)) (snd V956)))
    (byte->string (hd (fst V956))))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<strc> (V957)
 (let Result
  (if (cons? (fst V957))
   (shen-reassemble (fst (shen-reassemble (tl (fst V957)) (snd V957)))
    (if (= (hd (fst V957)) 34) (fail) (byte->string (hd (fst V957)))))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<backslash> (V958)
 (let Result
  (if (cons? (fst V958))
   (shen-reassemble (fst (shen-reassemble (tl (fst V958)) (snd V958)))
    (if (= (hd (fst V958)) 92) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<number> (V959)
 (let Result
  (let Parse_<minus> (shen-<minus> V959)
   (if (not (= (fail) Parse_<minus>))
    (let Parse_<number> (shen-<number> Parse_<minus>)
     (if (not (= (fail) Parse_<number>))
      (shen-reassemble (fst Parse_<number>) (- 0 (snd Parse_<number>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<plus> (shen-<plus> V959)
     (if (not (= (fail) Parse_<plus>))
      (let Parse_<number> (shen-<number> Parse_<plus>)
       (if (not (= (fail) Parse_<number>))
        (shen-reassemble (fst Parse_<number>) (snd Parse_<number>)) (fail)))
      (fail)))
    (if (= Result (fail))
     (let Result
      (let Parse_<predigits> (shen-<predigits> V959)
       (if (not (= (fail) Parse_<predigits>))
        (let Parse_<stop> (shen-<stop> Parse_<predigits>)
         (if (not (= (fail) Parse_<stop>))
          (let Parse_<postdigits> (shen-<postdigits> Parse_<stop>)
           (if (not (= (fail) Parse_<postdigits>))
            (shen-reassemble (fst Parse_<postdigits>)
             (+ (shen-pre (reverse (snd Parse_<predigits>)) 0)
              (shen-post (snd Parse_<postdigits>) 1)))
            (fail)))
          (fail)))
        (fail)))
      (if (= Result (fail))
       (let Result
        (let Parse_<digits> (shen-<digits> V959)
         (if (not (= (fail) Parse_<digits>))
          (shen-reassemble (fst Parse_<digits>)
           (shen-pre (reverse (snd Parse_<digits>)) 0))
          (fail)))
        (if (= Result (fail)) (fail) Result))
       Result))
     Result))
   Result)))

(defun shen-<plus> (V960)
 (let Result
  (if (cons? (fst V960))
   (shen-reassemble (fst (shen-reassemble (tl (fst V960)) (snd V960)))
    (if (= (hd (fst V960)) 43) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<stop> (V961)
 (let Result
  (if (cons? (fst V961))
   (shen-reassemble (fst (shen-reassemble (tl (fst V961)) (snd V961)))
    (if (= (hd (fst V961)) 46) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<predigits> (V962)
 (let Result
  (let Parse_<digits> (shen-<digits> V962)
   (if (not (= (fail) Parse_<digits>))
    (shen-reassemble (fst Parse_<digits>) (snd Parse_<digits>)) (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V962)
     (if (not (= (fail) Parse_<e>)) (shen-reassemble (fst Parse_<e>) ())
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<postdigits> (V963)
 (let Result
  (let Parse_<digits> (shen-<digits> V963)
   (if (not (= (fail) Parse_<digits>))
    (shen-reassemble (fst Parse_<digits>) (snd Parse_<digits>)) (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<digits> (V964)
 (let Result
  (let Parse_<digit> (shen-<digit> V964)
   (if (not (= (fail) Parse_<digit>))
    (let Parse_<digits> (shen-<digits> Parse_<digit>)
     (if (not (= (fail) Parse_<digits>))
      (shen-reassemble (fst Parse_<digits>)
       (cons (snd Parse_<digit>) (snd Parse_<digits>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<digit> (shen-<digit> V964)
     (if (not (= (fail) Parse_<digit>))
      (shen-reassemble (fst Parse_<digit>) (cons (snd Parse_<digit>) ()))
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<digit> (V965)
 (let Result
  (if (cons? (fst V965))
   (shen-reassemble (fst (shen-reassemble (tl (fst V965)) (snd V965)))
    (if (shen-digit-byte? (hd (fst V965))) (shen-byte->digit (hd (fst V965)))
     (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-byte->digit (V966)
 (cond ((= 48 V966) 0) ((= 49 V966) 1) ((= 50 V966) 2)
  ((= 51 V966) 3) ((= 52 V966) 4) ((= 53 V966) 5) ((= 54 V966) 6)
  ((= 55 V966) 7) ((= 56 V966) 8) ((= 57 V966) 9)
  (true (shen-sys-error shen-byte->digit))))

(defun shen-pre (V969 V970)
 (cond ((= () V969) 0)
  ((cons? V969)
   (+ (* (shen-expt 10 V970) (hd V969)) (shen-pre (tl V969) (+ V970 1))))
  (true (shen-sys-error shen-pre))))

(defun shen-post (V973 V974)
 (cond ((= () V973) 0)
  ((cons? V973)
   (+ (* (shen-expt 10 (- 0 V974)) (hd V973))
    (shen-post (tl V973) (+ V974 1))))
  (true (shen-sys-error shen-post))))

(defun shen-expt (V977 V978)
 (cond ((= 0 V978) 1) ((> V978 0) (* V977 (shen-expt V977 (- V978 1))))
  (true (* 1.0 (/ (shen-expt V977 (+ V978 1)) V977)))))

(defun shen-<st_input1> (V979)
 (let Result
  (let Parse_<st_input> (shen-<st_input> V979)
   (if (not (= (fail) Parse_<st_input>))
    (shen-reassemble (fst Parse_<st_input>) (snd Parse_<st_input>)) (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<st_input2> (V980)
 (let Result
  (let Parse_<st_input> (shen-<st_input> V980)
   (if (not (= (fail) Parse_<st_input>))
    (shen-reassemble (fst Parse_<st_input>) (snd Parse_<st_input>)) (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<comment> (V981)
 (let Result
  (let Parse_<backslash> (shen-<backslash> V981)
   (if (not (= (fail) Parse_<backslash>))
    (let Parse_<times> (shen-<times> Parse_<backslash>)
     (if (not (= (fail) Parse_<times>))
      (let Parse_<any> (shen-<any> Parse_<times>)
       (if (not (= (fail) Parse_<any>))
        (let Parse_<times> (shen-<times> Parse_<any>)
         (if (not (= (fail) Parse_<times>))
          (let Parse_<backslash> (shen-<backslash> Parse_<times>)
           (if (not (= (fail) Parse_<backslash>))
            (shen-reassemble (fst Parse_<backslash>) shen-skip) (fail)))
          (fail)))
        (fail)))
      (fail)))
    (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<times> (V982)
 (let Result
  (if (cons? (fst V982))
   (shen-reassemble (fst (shen-reassemble (tl (fst V982)) (snd V982)))
    (if (= (hd (fst V982)) 42) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<any> (V983)
 (let Result
  (let Parse_<comment> (shen-<comment> V983)
   (if (not (= (fail) Parse_<comment>))
    (let Parse_<any> (shen-<any> Parse_<comment>)
     (if (not (= (fail) Parse_<any>))
      (shen-reassemble (fst Parse_<any>) shen-skip) (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<blah> (shen-<blah> V983)
     (if (not (= (fail) Parse_<blah>))
      (let Parse_<any> (shen-<any> Parse_<blah>)
       (if (not (= (fail) Parse_<any>))
        (shen-reassemble (fst Parse_<any>) shen-skip) (fail)))
      (fail)))
    (if (= Result (fail))
     (let Result
      (let Parse_<e> (<e> V983)
       (if (not (= (fail) Parse_<e>))
        (shen-reassemble (fst Parse_<e>) shen-skip) (fail)))
      (if (= Result (fail)) (fail) Result))
     Result))
   Result)))

(defun shen-<blah> (V984)
 (let Result
  (if (cons? (fst V984))
   (shen-reassemble (fst (shen-reassemble (tl (fst V984)) (snd V984)))
    (if (shen-end-of-comment? (fst V984)) (fail) shen-skip))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-end-of-comment? (V991)
 (cond
  ((and (cons? V991)
    (and (= 42 (hd V991)) (and (cons? (tl V991)) (= 92 (hd (tl V991))))))
   true)
  (true false)))

(defun shen-<whitespaces> (V992)
 (let Result
  (let Parse_<whitespace> (shen-<whitespace> V992)
   (if (not (= (fail) Parse_<whitespace>))
    (let Parse_<whitespaces> (shen-<whitespaces> Parse_<whitespace>)
     (if (not (= (fail) Parse_<whitespaces>))
      (shen-reassemble (fst Parse_<whitespaces>) shen-skip) (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<whitespace> (shen-<whitespace> V992)
     (if (not (= (fail) Parse_<whitespace>))
      (shen-reassemble (fst Parse_<whitespace>) shen-skip) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<whitespace> (V993)
 (let Result
  (if (cons? (fst V993))
   (shen-reassemble (fst (shen-reassemble (tl (fst V993)) (snd V993)))
    (let Case (hd (fst V993))
     (if (= Case 32) shen-skip
      (if (= Case 13) shen-skip
       (if (= Case 10) shen-skip (if (= Case 9) shen-skip (fail)))))))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-cons_form (V994)
 (cond ((= () V994) ())
  ((and (cons? V994)
    (and (cons? (tl V994))
     (and (= bar! (hd (tl V994)))
      (and (cons? (tl (tl V994))) (= () (tl (tl (tl V994))))))))
   (cons cons (cons (hd V994) (tl (tl V994)))))
  ((cons? V994)
   (cons cons (cons (hd V994) (cons (shen-cons_form (tl V994)) ()))))
  (true (shen-sys-error shen-cons_form))))

(defun shen-package-macro (V997 V998)
 (cond
  ((and (cons? V997)
    (and (= package (hd V997))
     (and (cons? (tl V997))
      (and (= null (hd (tl V997))) (cons? (tl (tl V997)))))))
   (append (tl (tl (tl V997))) V998))
  ((and (cons? V997)
    (and (= package (hd V997))
     (and (cons? (tl V997)) (cons? (tl (tl V997))))))
   (append
    (shen-packageh (hd (tl V997)) (eval-without-macros (hd (tl (tl V997))))
     (tl (tl (tl V997))))
    V998))
  (true (cons V997 V998))))

(defun shen-packageh (V1007 V1008 V1009)
 (cond
  ((cons? V1009)
   (cons (shen-packageh V1007 V1008 (hd V1009))
    (shen-packageh V1007 V1008 (tl V1009))))
  ((or (shen-sysfunc? V1009)
    (or (variable? V1009)
     (or (element? V1009 V1008)
      (or (shen-doubleunderline? V1009) (shen-singleunderline? V1009)))))
   V1009)
  ((and (symbol? V1009)
    (not
     (shen-prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "-" ())))))
      (explode V1009))))
   (concat V1007 V1009))
  (true V1009)))

